/**
 * day276.h
 *
 * By Sebastian Raaphorst, 2020.
 */

#pragma once

#include <iterator>
#include <string>
#include <vector>
#include <map>

namespace dcp::day276 {
    /**
     * Details used by the main algorithm, as seen below.
     */
    namespace details {
        /**
         * Calculate the positions of the longest suffixes of pattern x ending at each position in x.
         * We traverse right-to-left across x.
         * For i in [0, m-1], suffixes[i] is the length of the longest suffix of x ending at position i in x.
         * @param x the pattern for which to search
         * @return the array of suffix lengths
         */
        std::vector<int> calculateSuffixes(const std::string &x) {
            const int m = x.size();

            std::vector<int> suffixes(m);
            suffixes[m - 1] = m;

            int f = 0;
            int g = m-1;

            for (int i = m - 2; i >= 0; --i) {
                if (i > g && suffixes[i + m - 1 - f] < i - g) {
                    suffixes[i] = suffixes[i + m - 1 - f];
                } else {
                    g = std::min(g, i);
                    f = i;
                    while (g >= 0 && x[g] == x[g + m - 1 - f])
                        --g;
                    suffixes[i] = f - g;
                }
            }
            return suffixes;
        }

        /**
         * Calculate the strong matching data for x.
         * @param x the pattern for which to search
         * @param suffixes the suffixes generated by calculateSuffixes
         * @return the vector of matching data
         */
        std::vector<int> calculateStrongMatching(const std::string &x, const std::vector<int> &suffixes) {
            const int m = x.size();
            int j = 0;

            std::vector<int> match(m);

            for (int i = m - 1; i >= -1; --i) {
                if (i == -1 || suffixes[i] == i + 1) {
                    while (j < m - 1 - i) {
                        match[j] = m - 1 - i;
                        ++j;
                    }
                }
            }
            for (int i = 0; i <= m - 2; ++i)
                match[m - 1 - suffixes[i]] = m - 1 - i;

            return match;
        }

        /**
         * Calculate the occurrence shift.
         * @param x the pattern for which to search
         * @return a map of character to shift
         */
        std::map<char, int> calculateOccurrenceShift(const std::string &x) {
            const int m = x.size();
            std::map<char, int> occurrenceShift;

            for (const char a: x) {
                for (int i = 1; i <= m - 1; ++i)
                    if (x[m - 1 - i] == a) {
                        occurrenceShift[a] = i;
                        break;
                    }
            }

            return occurrenceShift;
        }
    }

    /**
     * The search algorithm, Apostolic-Giancarlo.
     * It takes a pattern x and returns all locations of the pattern in a body of text, y.
     * @param x the pattern for which to search
     * @param y the body of text in which to search
     * @return a vector of the positions of the pattern in the body of text.
     */
    std::vector<int> apostolicoGiancarlo(const std::string &x, const std::string &y) {
        const int m = x.size();
        const int n = y.size();

        const auto suffixes = details::calculateSuffixes(x);
        const auto matches = details::calculateStrongMatching(x, suffixes);
        const auto occurrenceShift = details::calculateOccurrenceShift(x);

        std::vector<int> skip(n);
        std::vector<int> positions;

        int j = 0;
        while (j <= n - m) {
            int i = m - 1;
            while (i >= 0) {
                if (skip[i + j] == 0) {
                    if (x[i] == y[i+j]) --i;
                    else break;
                }
                else if (skip[i + j] > suffixes[i]) {
                    i -= suffixes[i];
                    break;
                }
                else if (skip[i + j] < suffixes[i]) {
                    i -= skip[i + j];
                    break;
                }
                else {
                    i -= suffixes[i];
                }
            }
            skip[i + j] = m - i - 1;
            if (i < 0) {
                positions.push_back(j);
                j += matches[0];
            } else {
                const auto lookup = occurrenceShift.find(y[i + j]);
                const auto value = (lookup == std::cend(occurrenceShift)) ? m : lookup->second;
                j += std::max(matches[i], value - m + i + 1);
            }
        }

        return positions;
    }

    /**
     * An alias to apostolicGiancarlo for convenience.
     */
    const auto &search = apostolicoGiancarlo;
}
